<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Valent칤nka pre Sarinku</title>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #E6E6FA; 
            font-family: sans-serif;
            touch-action: none; 
            user-select: none; 
            -webkit-user-select: none;
            cursor: grab; 
        }
        
        body:active {
            cursor: grabbing;
        }

        #game-layer {
            display: none; 
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #valentine-text {
            position: absolute;
            top: 5%;
            width: 100%;
            text-align: center;
            font-family: 'Pacifico', cursive;
            font-size: 28px;
            color: #6a5acd;
            text-shadow: 2px 2px 0px rgba(255, 255, 255, 0.5);
            z-index: 5;
            pointer-events: none;
            padding: 0 10px;
            box-sizing: border-box;
        }
        
        /* Nov칳 text pre "Hupsik" moment */
        #oops-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* ZMENA: Oby캜ajn칳 font namiesto Pacifico */
            font-family: sans-serif; 
            font-size: 20px; /* Trochu men코ie pre oby캜ajn칳 text */
            font-weight: bold;
            color: #d32f2f; /* 캛erven치 */
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 20; /* Nad v코etk칳m */
            pointer-events: none;
            display: none; /* Skryt칠 defaultne */
            text-align: center;
            width: 80%;
            max-width: 400px;
            border: 2px solid #ffcdd2;
        }

        #center-image {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35vw; 
            max-width: 200px;
            height: 35vh;
            max-height: 250px;
            background-color: #007bff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: flex; 
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            z-index: 2;
        }

        /* U-캜kov칠 ko코칤ky */
        .basket {
            position: absolute;
            bottom: 5%; 
            width: 28vw;
            height: 35vh; 
            border-left: 8px solid rgba(255, 255, 255, 0.8);
            border-right: 8px solid rgba(255, 255, 255, 0.8);
            border-bottom: 8px solid rgba(255, 255, 255, 0.8);
            border-top: none;
            border-radius: 0 0 25px 25px;
            
            display: flex;
            flex-direction: column;
            align-items: center; 
            justify-content: flex-end;
            padding-bottom: 10px;
            
            font-weight: bold;
            font-size: 24px;
            color: white;
            box-sizing: border-box;
            z-index: 1;
            transition: border-bottom-color 0.3s; /* Anim치cia pre zmiznutie dna */
        }
        
        /* Trieda pre "rozbit칳" ko코칤k - dno zmizne */
        .basket.broken {
            border-bottom-color: transparent !important;
        }

        .counter {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 2px 10px;
            border-radius: 10px;
            font-size: 18px;
            margin-top: 5px;
            font-family: monospace;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #basket-yes {
            left: 5%;
            background-color: rgba(76, 175, 80, 0.3); 
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.4);
            text-shadow: 0 1px 2px black;
        }

        #basket-no {
            right: 5%;
            background-color: rgba(244, 67, 54, 0.3); 
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.4);
            text-shadow: 0 1px 2px black;
        }

        #hearts-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3; 
            pointer-events: none; 
            display: none; 
        }

        .heart {
            position: absolute;
            will-change: transform;
        }

        .heart svg path {
            transition: fill 0.3s ease, stroke 0.3s ease;
        }

        .heart.green svg path:first-child {
            fill: rgba(76, 175, 80, 0.8) !important;
            stroke: #2E7D32 !important;
        }

        .heart.red svg path:first-child {
            fill: rgba(244, 67, 54, 0.8) !important;
            stroke: #C62828 !important;
        }

        #start-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 50px;
            background: white;
            border: none;
            border-radius: 50px;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            cursor: pointer;
            z-index: 10;
            color: #333;
            transition: transform 0.2s;
        }
        
        #start-btn:active {
            transform: translate(-50%, -50%) scale(0.95);
        }

        #instruction {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #6a5acd; 
            font-size: 16px;
            pointer-events: none;
            opacity: 0; 
            transition: opacity 1.5s;
            z-index: 5;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(255,255,255,0.8);
            display: none; 
        }
    </style>
</head>
<body>

    <div id="game-layer">
        <h1 id="valentine-text">Bude코 moja valent칤nka Sarinka?</h1>
        
        <div id="basket-yes" class="basket">
            <span>츼NO</span>
            <div id="count-yes" class="counter">0</div>
        </div>
        
        <div id="center-image">OBR츼ZOK</div>
        
        <div id="basket-no" class="basket">
            <span>NIE</span>
            <div id="count-no" class="counter">0</div>
        </div>

        <div id="oops-text">Hupsik, asi som zabudol ten ko코칤k opravi콘 游뱘</div>
    </div>

    <div id="hearts-container"></div>
    <div id="instruction">Chy콘 bublinky a vho캞 ich do ko코칤kov!</div>
    <button id="start-btn">Ahoj</button>

    <script>
        const container = document.getElementById('hearts-container');
        const startBtn = document.getElementById('start-btn');
        const gameLayer = document.getElementById('game-layer');
        const instructionTxt = document.getElementById('instruction');
        const basketYesEl = document.getElementById('basket-yes');
        const basketNoEl = document.getElementById('basket-no');
        const countYesEl = document.getElementById('count-yes');
        const countNoEl = document.getElementById('count-no');
        const oopsTextEl = document.getElementById('oops-text');
        
        let tiltX = 0; 
        let tiltY = 0; 

        // Kalibra캜n칠 premenn칠
        let calibrationOffsetBeta = 0;
        let initialCalibrationBeta = 0; 
        let isCalibrated = false;
        let isOnTable = false; 
        
        let flatStableStartTime = 0;
        let lastBeta = 0;
        let lastGamma = 0;

        // Stav rozbit칠ho ko코칤ka
        let isBasketBroken = false;
        let basketBreakTimeout = null;
        
        const hearts = [];
        const numHearts = 40; 
        
        let width = window.innerWidth;
        let height = window.innerHeight;

        const activeDrags = new Map();

        function createHeart() {
            const size = Math.random() * 40 + 30; 
            const normalizedSize = (size - 30) / 40; 
            const sensitivity = 0.05 + (normalizedSize * 0.20);

            const element = document.createElement('div');
            element.classList.add('heart');
            element.style.width = `${size}px`;
            element.style.height = `${size}px`;
            
            const opacity = 0.6 + (normalizedSize * 0.4); 
            element.style.opacity = opacity;

            element.innerHTML = `
                <svg viewBox="0 0 32 29.6" style="width: 100%; height: 100%; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-11.8,16-21.2C32,3.8,28.2,0,23.6,0z" 
                    fill="rgba(255, 255, 255, 0.25)" 
                    stroke="white" 
                    stroke-width="1.5"/>
                    <path d="M6,6 Q10,2 14,6" fill="none" stroke="rgba(255,255,255,0.6)" stroke-width="2" stroke-linecap="round" />
                </svg>
            `;

            container.appendChild(element);

            return {
                element: element,
                x: Math.random() * (width * 1.5) - (width * 0.25),
                y: Math.random() * (height * 1.5) - (height * 0.25),
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                size: size,
                sensitivity: sensitivity,
                friction: 0.98,
                swayPhase: Math.random() * Math.PI * 2,
                swaySpeed: 0.001 + Math.random() * 0.002,
                isDragged: false,
                currentBasket: null 
            };
        }

        function initHearts() {
            for (let i = 0; i < numHearts; i++) {
                hearts.push(createHeart());
            }
        }

        function getBasketRect(type) {
            const el = type === 'yes' ? basketYesEl : basketNoEl;
            const rect = el.getBoundingClientRect();
            return {
                left: rect.left + 8,
                right: rect.right - 8,
                top: rect.top,
                bottom: rect.bottom - 8
            };
        }

        function checkBasketEntry(heart) {
            const hCx = heart.x + heart.size / 2;
            const hCy = heart.y + heart.size / 2;

            const baskets = ['yes', 'no'];
            for (let type of baskets) {
                const rect = getBasketRect(type);
                if (hCx > rect.left && hCx < rect.right && hCy > rect.top && hCy < rect.bottom) {
                    return type;
                }
            }
            return null;
        }

        // Funkcia na "rozbitie" ko코칤ka
        function breakBasket() {
            if (isBasketBroken) return; // Ak je u rozbit칳, nerob칤me ni캜 navy코e (timer be쮂)
            
            isBasketBroken = true;
            basketNoEl.classList.add('broken');
            oopsTextEl.style.display = 'block';

            if (basketBreakTimeout) clearTimeout(basketBreakTimeout);
            
            basketBreakTimeout = setTimeout(() => {
                isBasketBroken = false;
                basketNoEl.classList.remove('broken');
                oopsTextEl.style.display = 'none';
            }, 3000);
        }

        function updateFloatingPhysics(h, time, buffer) {
            h.vx += tiltX * h.sensitivity * 0.5; 
            h.vy += tiltY * h.sensitivity * 0.5;
            
            h.vx += Math.cos(time * h.swaySpeed + h.swayPhase) * 0.03;
            h.vy += Math.sin(time * h.swaySpeed + h.swayPhase) * 0.03;

            h.vx *= h.friction;
            h.vy *= h.friction;

            if (h.x > width + buffer) h.x = -buffer;
            else if (h.x < -buffer) h.x = width + buffer;
            if (h.y > height + buffer) h.y = -buffer;
            else if (h.y < -buffer) h.y = height + buffer;
        }

        function updateBasketPhysics(h) {
            const rect = getBasketRect(h.currentBasket);
            
            h.vx += tiltX * 0.8; 
            h.vy += tiltY * 0.8 + 0.2; 

            h.vx *= 0.95;
            h.vy *= 0.95;

            let nextX = h.x + h.vx;
            let nextY = h.y + h.vy;

            // Logika pre ko코칤k NIE (trap door)
            if (h.currentBasket === 'no') {
                // Ak e코te nie je rozbit칳 a bublina sa bl칤쬴 ku dnu, rozbijeme ho
                if (!isBasketBroken && nextY + h.size > rect.bottom - 15) {
                    breakBasket();
                }
            }

            // Kol칤zie so stenami
            if (nextX < rect.left) {
                nextX = rect.left;
                h.vx *= -0.6; 
            }
            else if (nextX + h.size > rect.right) {
                nextX = rect.right - h.size;
                h.vx *= -0.6;
            }

            // Kol칤zia s dnom
            if (nextY + h.size > rect.bottom) {
                // Ak je to ko코칤k NIE a je rozbit칳, ignorujeme dno -> pad치 캞alej
                if (h.currentBasket === 'no' && isBasketBroken) {
                    // Nech치me ho padn칰콘 (쬴adna korekcia nextY)
                } else {
                    // 맚andardn칳 odraz od dna
                    nextY = rect.bottom - h.size;
                    h.vy *= -0.5; 
                }
            }

            // Opustenie ko코칤ka vrchom
            if (nextY < rect.top - h.size) {
                h.currentBasket = null;
                h.vy -= 2; 
            }
            
            // Opustenie ko코칤ka spodkom (prepade cez dieru)
            // Ke캞 prepadne dostato캜ne hlboko pod ko코칤k
            if (h.currentBasket === 'no' && nextY > rect.bottom + h.size) {
                h.currentBasket = null; // Prestane by콘 v ko코칤ku -> po캜칤tadlo klesne
                // Nasleduj칰ci frame prevezme floating physics
            }

            h.x = nextX;
            h.y = nextY;
        }

        function animate() {
            const buffer = 80;
            const time = Date.now();
            
            let cYes = 0;
            let cNo = 0;

            for (let i = 0; i < hearts.length; i++) {
                let h = hearts[i];

                if (h.isDragged) {
                    h.vx = 0;
                    h.vy = 0;
                    h.element.classList.remove('green', 'red');
                    h.element.style.transform = `translate(${h.x}px, ${h.y}px)`;
                    continue;
                }

                if (h.currentBasket) {
                    updateBasketPhysics(h);
                    
                    if (h.currentBasket === 'yes') {
                        h.element.classList.add('green');
                        h.element.classList.remove('red');
                        cYes++;
                    } else if (h.currentBasket === 'no') {
                        h.element.classList.add('red');
                        h.element.classList.remove('green');
                        cNo++;
                    }
                } else {
                    h.element.classList.remove('green', 'red');
                    updateFloatingPhysics(h, time, buffer);
                    h.x += h.vx;
                    h.y += h.vy;
                }
                
                for (let j = 0; j < hearts.length; j++) {
                    if (i === j) continue;
                    let h2 = hearts[j];
                    if (!!h.currentBasket !== !!h2.currentBasket) continue;

                    let dx = h.x - h2.x;
                    let dy = h.y - h2.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    let minDist = (h.size/2 + h2.size/2) * 1.1; 

                    if (dist < minDist && dist > 0) {
                        let force = (minDist - dist) / minDist; 
                        let pushX = (dx / dist) * force * 0.2;
                        let pushY = (dy / dist) * force * 0.2;
                        h.vx += pushX;
                        h.vy += pushY;
                    }
                }

                const maxSpeed = h.currentBasket ? 15.0 : 5.0; 
                const speed = Math.sqrt(h.vx*h.vx + h.vy*h.vy);
                if (speed > maxSpeed) {
                    h.vx = (h.vx / speed) * maxSpeed;
                    h.vy = (h.vy / speed) * maxSpeed;
                }

                h.element.style.transform = `translate(${h.x}px, ${h.y}px)`;
            }

            countYesEl.innerText = cYes;
            countNoEl.innerText = cNo;

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
        });

        function handleOrientation(event) {
            const rawX = event.gamma || 0; 
            const rawY = event.beta || 0;
            
            if (!isCalibrated) {
                if (rawY >= 18 && rawY <= 55) {
                    initialCalibrationBeta = rawY;
                } else {
                    initialCalibrationBeta = 40;
                }
                calibrationOffsetBeta = initialCalibrationBeta;
                isCalibrated = true;
            }

            const speed = Math.abs(rawY - lastBeta) + Math.abs(rawX - lastGamma);
            
            if (Math.abs(rawY) <= 3 && Math.abs(rawX) <= 3 && speed < 0.5) {
                if (flatStableStartTime === 0) {
                    flatStableStartTime = Date.now();
                } else if (Date.now() - flatStableStartTime > 1000) {
                    calibrationOffsetBeta = 0;
                    isOnTable = true;
                }
            } else {
                flatStableStartTime = 0;
            }

            if (isOnTable && rawY > 15) {
                calibrationOffsetBeta = initialCalibrationBeta;
                isOnTable = false;
            }

            lastBeta = rawY;
            lastGamma = rawX;

            const effectiveY = rawY - calibrationOffsetBeta;

            tiltX = rawX / 45; 
            tiltY = effectiveY / 45; 
        }

        function findHeartAt(x, y) {
            for (let i = hearts.length - 1; i >= 0; i--) {
                let h = hearts[i];
                if (h.isDragged) continue; 
                if (x >= h.x - 20 && x <= h.x + h.size + 20 &&
                    y >= h.y - 20 && y <= h.y + h.size + 20) {
                    return h;
                }
            }
            return null;
        }

        window.addEventListener('touchstart', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const h = findHeartAt(t.clientX, t.clientY);
                if (h) {
                    h.isDragged = true;
                    h.currentBasket = null;
                    h.element.style.opacity = '1'; 
                    h.element.classList.remove('green', 'red');
                    
                    activeDrags.set(t.identifier, {
                        heart: h,
                        offX: t.clientX - h.x,
                        offY: t.clientY - h.y
                    });
                }
            }
        }, {passive: false});

        window.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const dragData = activeDrags.get(t.identifier);
                if (dragData) {
                    dragData.heart.x = t.clientX - dragData.offX;
                    dragData.heart.y = t.clientY - dragData.offY;
                }
            }
        }, {passive: false});

        function endTouch(e) {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const dragData = activeDrags.get(t.identifier);
                if (dragData) {
                    dragData.heart.isDragged = false;
                    
                    const basketType = checkBasketEntry(dragData.heart);
                    if (basketType) {
                        dragData.heart.currentBasket = basketType;
                    } else {
                        const normalizedSize = (dragData.heart.size - 30) / 40;
                        dragData.heart.element.style.opacity = 0.6 + (normalizedSize * 0.4);
                    }
                    activeDrags.delete(t.identifier);
                }
            }
        }
        window.addEventListener('touchend', endTouch);
        window.addEventListener('touchcancel', endTouch);

        window.addEventListener('mousedown', (e) => {
            const h = findHeartAt(e.clientX, e.clientY);
            if (h) {
                h.isDragged = true;
                h.currentBasket = null;
                h.element.style.opacity = '1';
                h.element.classList.remove('green', 'red');
                activeDrags.set('mouse', {
                    heart: h,
                    offX: e.clientX - h.x,
                    offY: e.clientY - h.y
                });
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (activeDrags.size === 0 && (!window.DeviceOrientationEvent || !('ontouchstart' in window))) {
                const centerX = width / 2;
                const centerY = height / 2;
                tiltX = (e.clientX - centerX) / centerX;
                tiltY = (e.clientY - centerY) / centerY;
            }
            const dragData = activeDrags.get('mouse');
            if (dragData) {
                dragData.heart.x = e.clientX - dragData.offX;
                dragData.heart.y = e.clientY - dragData.offY;
            }
        });

        window.addEventListener('mouseup', () => {
            const dragData = activeDrags.get('mouse');
            if (dragData) {
                dragData.heart.isDragged = false;
                const basketType = checkBasketEntry(dragData.heart);
                if (basketType) {
                    dragData.heart.currentBasket = basketType;
                } else {
                    const normalizedSize = (dragData.heart.size - 30) / 40;
                    dragData.heart.element.style.opacity = 0.6 + (normalizedSize * 0.4);
                }
                activeDrags.delete('mouse');
            }
        });

        function startGame() {
            startBtn.style.display = 'none';
            gameLayer.style.display = 'block';
            container.style.display = 'block';
            instructionTxt.style.display = 'block';
            setTimeout(() => instructionTxt.style.opacity = 1, 100);
            initHearts();
            animate();
        }

        startBtn.addEventListener('click', () => {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                        }
                        startGame();
                    })
                    .catch(e => {
                        console.error(e);
                        startGame();
                    });
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
                startGame();
            }
        });
    </script>
</body>
</html>
