<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Valent√≠nka pre Sarinku</title>
    <!-- Ikonka fialov√© srdieƒçko -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üíú</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #E6E6FA; 
            font-family: sans-serif;
            touch-action: none; 
            user-select: none; 
            -webkit-user-select: none;
            cursor: grab; 
        }
        
        body:active {
            cursor: grabbing;
        }

        #game-layer {
            display: none; 
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #valentine-text {
            position: absolute;
            top: 5%;
            width: 100%;
            text-align: center;
            font-family: 'Pacifico', cursive;
            font-size: 28px;
            color: #6a5acd;
            text-shadow: 2px 2px 0px rgba(255, 255, 255, 0.5);
            z-index: 5;
            pointer-events: none;
            padding: 0 10px;
            box-sizing: border-box;
        }
        
        /* Obyƒçajn√Ω Hupsik text (1. pokus) */
        #oops-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: sans-serif; 
            font-size: 20px; 
            font-weight: bold;
            color: #d32f2f; 
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 20; 
            pointer-events: none;
            display: none; 
            text-align: center;
            width: 80%;
            max-width: 400px;
            border: 2px solid #ffcdd2;
        }

        /* Varovn√Ω box pre pokusy 2-4 */
        #warning-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 25;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
        }

        #warning-image-container {
            width: 250px; 
            height: 200px;
            background-color: #fff; 
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex; 
            align-items: center;
            justify-content: center;
            border: 4px solid white;
            margin-bottom: 10px;
            overflow: hidden;
        }

        #warning-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Tu m√¥≈æeme da≈• cover, nech to vyzer√° ako fotka */
        }

        #warning-caption {
            font-family: sans-serif;
            font-size: 22px;
            font-weight: bold;
            color: #d32f2f;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        /* SUCCESS MESSAGE (V√Ωhra) */
        #success-message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none; 
            flex-direction: column;
            align-items: center;
            z-index: 30;
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        #success-image-container {
            width: 35vw; 
            max-width: 250px;
            height: 35vh;
            max-height: 300px;
            background-color: #ff69b4; 
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(255, 105, 180, 0.5);
            display: flex; 
            align-items: center;
            justify-content: center;
            border: 4px solid white;
            overflow: hidden;
        }

        #success-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #success-caption {
            font-family: 'Pacifico', cursive;
            font-size: 32px;
            color: #6a5acd;
            margin-top: 15px;
            text-shadow: 2px 2px 0px rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 15px;
            border-radius: 20px;
        }

        /* Centr√°lny obr√°zok s Slideshow - UPRAVEN√â */
        #center-image {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* Odstr√°nen√© fixn√© rozmery, nahraden√© dynamick√Ωmi v JS */
            width: 200px; /* Default */
            height: 200px; /* Default */
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            z-index: 2;
            overflow: hidden; 
            /* Pridan√° transition pre plynul√∫ zmenu veƒækosti */
            transition: width 0.5s ease, height 0.5s ease;
        }

        #center-image img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Obr√°zok sa prisp√¥sob√≠ r√°mu */
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        #center-image img.active {
            opacity: 1;
        }

        .basket {
            position: absolute;
            bottom: 5%; 
            width: 28vw;
            height: 35vh; 
            border-left: 8px solid rgba(255, 255, 255, 0.8);
            border-right: 8px solid rgba(255, 255, 255, 0.8);
            border-bottom: 8px solid rgba(255, 255, 255, 0.8);
            border-top: none;
            border-radius: 0 0 25px 25px;
            display: flex;
            flex-direction: column;
            align-items: center; 
            justify-content: flex-end;
            padding-bottom: 10px;
            font-weight: bold;
            font-size: 24px;
            color: white;
            box-sizing: border-box;
            z-index: 1;
            transition: border-bottom-color 0.3s, opacity 0.5s; 
        }
        
        .basket.broken {
            border-bottom-color: transparent !important;
        }

        /* Hups - ko≈°√≠k zmizol */
        #basket-gone-message {
            position: absolute;
            bottom: 5%;
            right: 5%; 
            width: 28vw;
            display: none; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto; 
            cursor: pointer; 
            z-index: 1;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #basket-gone-image-container {
            width: 120px;
            height: 120px;
            background-color: #9e9e9e; 
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
            margin-bottom: 10px;
            overflow: hidden;
        }

        #basket-gone-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #basket-gone-caption {
            font-family: sans-serif;
            font-size: 18px;
            font-weight: bold;
            color: #6a5acd;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 15px;
            border-radius: 15px;
        }

        .counter {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 2px 10px;
            border-radius: 10px;
            font-size: 18px;
            margin-top: 5px;
            font-family: monospace;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #basket-yes {
            left: 5%;
            background-color: rgba(76, 175, 80, 0.3); 
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.4);
            text-shadow: 0 1px 2px black;
        }

        #basket-no {
            right: 5%;
            background-color: rgba(244, 67, 54, 0.3); 
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.4);
            text-shadow: 0 1px 2px black;
        }

        #hearts-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3; 
            pointer-events: none; 
            display: none; 
        }

        .heart {
            position: absolute;
            will-change: transform;
        }

        .heart svg path {
            transition: fill 0.3s ease, stroke 0.3s ease;
        }

        .heart.green svg path:first-child {
            fill: rgba(76, 175, 80, 0.8) !important;
            stroke: #2E7D32 !important;
        }

        .heart.red svg path:first-child {
            fill: rgba(244, 67, 54, 0.8) !important;
            stroke: #C62828 !important;
        }

        #start-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 50px;
            background: white;
            border: none;
            border-radius: 50px;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            cursor: pointer;
            z-index: 10;
            color: #333;
            transition: transform 0.2s;
        }
        
        #start-btn:active {
            transform: translate(-50%, -50%) scale(0.95);
        }

        #instruction {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #6a5acd; 
            font-size: 16px;
            pointer-events: none;
            opacity: 0; 
            transition: opacity 1.5s;
            z-index: 5;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(255,255,255,0.8);
            display: none; 
        }
    </style>
</head>
<body>

    <div id="game-layer">
        <h1 id="valentine-text">Bude≈° moja valent√≠nka Sarinka?</h1>
        
        <div id="basket-yes" class="basket">
            <span>√ÅNO</span>
            <div id="count-yes" class="counter">0</div>
        </div>
        
        <!-- Centr√°lny obr√°zok (Slideshow) -->
        <div id="center-image">
            <img id="slide-1" class="active" src="Fotky/center/1.jpg" alt="Foto">
            <img id="slide-2" src="Fotky/center/2.jpg" alt="Foto">
        </div>
        
        <!-- V√Ωhra (Jup√≠) -->
        <div id="success-message">
            <div id="success-image-container">
                <img src="Fotky/ostatne/jupi.jpg" alt="Jup√≠">
            </div>
            <div id="success-caption">Jejoo! ‚ù§Ô∏è</div>
        </div>
        
        <div id="basket-no" class="basket">
            <span>NIE</span>
            <div id="count-no" class="counter">0</div>
        </div>

        <!-- Basket Gone (Hups) -->
        <div id="basket-gone-message">
            <div id="basket-gone-image-container">
                <img src="Fotky/filip-nahnevany/hups.jpg" alt="Hups">
            </div>
            <div id="basket-gone-caption">Hups ü§∑‚Äç‚ôÇÔ∏è</div>
        </div>

        <div id="oops-text">Hupsik, asi som zabudol ten ko≈°√≠k opravi≈• ü§≠</div>

        <!-- Varovanie (Filip nahnevan√Ω) -->
        <div id="warning-message">
            <div id="warning-image-container">
                <img id="warning-img" src="" alt="Varovanie">
            </div>
            <div id="warning-caption">Text</div>
        </div>
    </div>

    <div id="hearts-container"></div>
    <div id="instruction">Chy≈• bublinky a vhoƒè ich do ko≈°√≠kov!</div>
    <button id="start-btn">‚ù§Ô∏èüß°üíõüíöüíôüíúüñ§ü§ç Ahoj ü§çüñ§üíúüíôüíöüíõüß°‚ù§Ô∏è</button>

    <script>
        const container = document.getElementById('hearts-container');
        const startBtn = document.getElementById('start-btn');
        const gameLayer = document.getElementById('game-layer');
        const instructionTxt = document.getElementById('instruction');
        const basketYesEl = document.getElementById('basket-yes');
        const basketNoEl = document.getElementById('basket-no');
        const countYesEl = document.getElementById('count-yes');
        const countNoEl = document.getElementById('count-no');
        
        const oopsTextEl = document.getElementById('oops-text');
        const warningMsgEl = document.getElementById('warning-message');
        const warningImgEl = document.getElementById('warning-img');
        const warningCapEl = document.getElementById('warning-caption');
        
        const successMessageEl = document.getElementById('success-message');
        const basketGoneEl = document.getElementById('basket-gone-message');
        const centerImageFrame = document.getElementById('center-image');
        
        // Slideshow prvky
        const slide1 = document.getElementById('slide-1');
        const slide2 = document.getElementById('slide-2');
        
        let tiltX = 0; 
        let tiltY = 0; 

        let calibrationOffsetBeta = 0;
        let initialCalibrationBeta = 0; 
        let isCalibrated = false;
        let isOnTable = false; 
        
        let flatStableStartTime = 0;
        let lastBeta = 0;
        let lastGamma = 0;

        let isBasketBroken = false;
        let isBasketRemoved = false; 
        let noBasketCount = 0; 
        let basketBreakTimeout = null;
        
        const hearts = [];
        const numHearts = 40; 
        
        let width = window.innerWidth;
        let height = window.innerHeight;

        const activeDrags = new Map();

        // --- SLIDESHOW & RESIZE LOGIC ---
        let currentSlideIndex = 1;
        const totalSlides = 16;
        let activeImgElement = slide1;
        let nextImgElement = slide2;

        // Funkcia na √∫pravu veƒækosti r√°mu podƒæa obr√°zka
        function updateFrameSize(imgElement) {
            // Maxim√°lne rozmery (aby neprekr√Ωval ko≈°√≠ky a zmestil sa)
            // Cca 40% ≈°√≠rky a 35% v√Ω≈°ky obrazovky
            const maxW = window.innerWidth * 0.40;
            const maxH = window.innerHeight * 0.35;
            
            // Zist√≠me nat√≠vne rozmery (alebo fallback, ak e≈°te nie s√∫ naƒç√≠tan√©)
            const natW = imgElement.naturalWidth || 500;
            const natH = imgElement.naturalHeight || 500;
            
            // Vypoƒç√≠tame scale factor tak, aby sa obr√°zok zmestil do max boxu
            // Math.min zabezpeƒç√≠, ≈æe nepresiahneme ani ≈°√≠rku ani v√Ω≈°ku (contain)
            const scale = Math.min(maxW / natW, maxH / natH);
            
            // Nov√© rozmery r√°mu
            const finalW = natW * scale;
            const finalH = natH * scale;
            
            // Aplikujeme na r√°m
            centerImageFrame.style.width = `${finalW}px`;
            centerImageFrame.style.height = `${finalH}px`;
        }

        function startSlideshow() {
            setInterval(() => {
                currentSlideIndex++;
                if (currentSlideIndex > totalSlides) currentSlideIndex = 1;
                
                nextImgElement.src = `Fotky/center/${currentSlideIndex}.jpg`;
                
                // Keƒè sa naƒç√≠ta, prepoƒç√≠tame r√°m a swapneme
                nextImgElement.onload = () => {
                    updateFrameSize(nextImgElement);
                    
                    nextImgElement.classList.add('active');
                    activeImgElement.classList.remove('active');
                    
                    const temp = activeImgElement;
                    activeImgElement = nextImgElement;
                    nextImgElement = temp;
                };
                
            }, 5000); 
        }

        // --- HEART CREATION ---
        function createHeart() {
            const size = Math.random() * 40 + 30; 
            const normalizedSize = (size - 30) / 40; 
            const sensitivity = 0.05 + (normalizedSize * 0.20);

            const element = document.createElement('div');
            element.classList.add('heart');
            element.style.width = `${size}px`;
            element.style.height = `${size}px`;
            
            const opacity = 0.6 + (normalizedSize * 0.4); 
            element.style.opacity = opacity;

            element.innerHTML = `
                <svg viewBox="0 0 32 29.6" style="width: 100%; height: 100%; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-11.8,16-21.2C32,3.8,28.2,0,23.6,0z" 
                    fill="rgba(255, 255, 255, 0.25)" 
                    stroke="white" 
                    stroke-width="1.5"/>
                    <path d="M6,6 Q10,2 14,6" fill="none" stroke="rgba(255,255,255,0.6)" stroke-width="2" stroke-linecap="round" />
                </svg>
            `;

            container.appendChild(element);

            return {
                element: element,
                x: Math.random() * (width * 1.5) - (width * 0.25),
                y: Math.random() * (height * 1.5) - (height * 0.25),
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                size: size,
                sensitivity: sensitivity,
                friction: 0.98,
                swayPhase: Math.random() * Math.PI * 2,
                swaySpeed: 0.001 + Math.random() * 0.002,
                isDragged: false,
                currentBasket: null 
            };
        }

        function initHearts() {
            for (let i = 0; i < numHearts; i++) {
                hearts.push(createHeart());
            }
        }

        function getBasketRect(type) {
            const el = type === 'yes' ? basketYesEl : basketNoEl;
            const rect = el.getBoundingClientRect();
            return {
                left: rect.left + 8,
                right: rect.right - 8,
                top: rect.top,
                bottom: rect.bottom - 8
            };
        }

        function checkBasketEntry(heart) {
            const hCx = heart.x + heart.size / 2;
            const hCy = heart.y + heart.size / 2;

            const baskets = ['yes', 'no'];
            for (let type of baskets) {
                if (type === 'no' && isBasketRemoved) continue;

                const rect = getBasketRect(type);
                if (hCx > rect.left && hCx < rect.right && hCy > rect.top && hCy < rect.bottom) {
                    return type;
                }
            }
            return null;
        }

        function showWarning(text, imgSrc) {
            warningCapEl.innerText = text;
            warningImgEl.src = imgSrc;
            warningMsgEl.style.display = 'flex';
        }

        function hideWarning() {
            warningMsgEl.style.display = 'none';
        }

        function breakBasket() {
            if (isBasketBroken || isBasketRemoved) return; 
            
            noBasketCount++;
            
            if (noBasketCount >= 5) {
                isBasketRemoved = true;
                basketNoEl.style.display = 'none';
                basketGoneEl.style.display = 'flex'; 
                return;
            }

            isBasketBroken = true;
            basketNoEl.classList.add('broken');

            if (noBasketCount === 1) {
                oopsTextEl.innerText = "Hupsik, asi som zabudol ten ko≈°√≠k opravi≈• ü§≠";
                oopsTextEl.style.display = 'block';
            } else if (noBasketCount === 2) {
                showWarning("Ty ƒço sk√∫≈°a≈°?!", "Fotky/filip-nahnevany/ty_co_skusas.jpg"); 
            } else if (noBasketCount === 3) {
                showWarning("Presta≈à!", "Fotky/filip-nahnevany/prestan.jpg"); 
            } else if (noBasketCount === 4) {
                showWarning("Varujem ≈•a!", "Fotky/filip-nahnevany/varujem_ta.jpg"); 
            }

            if (basketBreakTimeout) clearTimeout(basketBreakTimeout);
            
            basketBreakTimeout = setTimeout(() => {
                isBasketBroken = false;
                basketNoEl.classList.remove('broken');
                oopsTextEl.style.display = 'none';
                hideWarning();
            }, 3000);
        }

        function updateFloatingPhysics(h, time, buffer) {
            h.vx += tiltX * h.sensitivity * 0.5; 
            h.vy += tiltY * h.sensitivity * 0.5;
            
            h.vx += Math.cos(time * h.swaySpeed + h.swayPhase) * 0.03;
            h.vy += Math.sin(time * h.swaySpeed + h.swayPhase) * 0.03;

            h.vx *= h.friction;
            h.vy *= h.friction;

            if (h.x > width + buffer) h.x = -buffer;
            else if (h.x < -buffer) h.x = width + buffer;
            if (h.y > height + buffer) h.y = -buffer;
            else if (h.y < -buffer) h.y = height + buffer;
        }

        function updateBasketPhysics(h) {
            const rect = getBasketRect(h.currentBasket);
            
            h.vx += tiltX * 0.8; 
            h.vy += tiltY * 0.8 + 0.2; 

            h.vx *= 0.95;
            h.vy *= 0.95;

            let nextX = h.x + h.vx;
            let nextY = h.y + h.vy;

            if (h.currentBasket === 'no') {
                if (!isBasketBroken && !isBasketRemoved && nextY + h.size > rect.bottom - 15) {
                    breakBasket();
                }
            }

            if (nextX < rect.left) {
                nextX = rect.left;
                h.vx *= -0.6; 
            }
            else if (nextX + h.size > rect.right) {
                nextX = rect.right - h.size;
                h.vx *= -0.6;
            }

            if (nextY + h.size > rect.bottom) {
                if (h.currentBasket === 'no' && (isBasketBroken || isBasketRemoved)) {
                    // Prepadne
                } else {
                    nextY = rect.bottom - h.size;
                    h.vy *= -0.5; 
                }
            }

            if (nextY < rect.top - h.size) {
                h.currentBasket = null;
                h.vy -= 2; 
            }
            
            if (h.currentBasket === 'no' && nextY > rect.bottom + h.size) {
                h.currentBasket = null; 
            }

            h.x = nextX;
            h.y = nextY;
        }

        function animate() {
            const buffer = 80;
            const time = Date.now();
            
            let cYes = 0;
            let cNo = 0;

            for (let i = 0; i < hearts.length; i++) {
                let h = hearts[i];

                if (h.isDragged) {
                    h.vx = 0;
                    h.vy = 0;
                    h.element.classList.remove('green', 'red');
                    h.element.style.transform = `translate(${h.x}px, ${h.y}px)`;
                    continue;
                }

                if (h.currentBasket) {
                    updateBasketPhysics(h);
                    
                    if (h.currentBasket === 'yes') {
                        h.element.classList.add('green');
                        h.element.classList.remove('red');
                        cYes++;
                    } else if (h.currentBasket === 'no') {
                        h.element.classList.add('red');
                        h.element.classList.remove('green');
                        cNo++;
                    }
                } else {
                    h.element.classList.remove('green', 'red');
                    updateFloatingPhysics(h, time, buffer);
                    h.x += h.vx;
                    h.y += h.vy;
                }
                
                for (let j = 0; j < hearts.length; j++) {
                    if (i === j) continue;
                    let h2 = hearts[j];
                    if (!!h.currentBasket !== !!h2.currentBasket) continue;

                    let dx = h.x - h2.x;
                    let dy = h.y - h2.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    let minDist = (h.size/2 + h2.size/2) * 1.1; 

                    if (dist < minDist && dist > 0) {
                        let force = (minDist - dist) / minDist; 
                        let pushX = (dx / dist) * force * 0.2;
                        let pushY = (dy / dist) * force * 0.2;
                        h.vx += pushX;
                        h.vy += pushY;
                    }
                }

                const maxSpeed = h.currentBasket ? 15.0 : 5.0; 
                const speed = Math.sqrt(h.vx*h.vx + h.vy*h.vy);
                if (speed > maxSpeed) {
                    h.vx = (h.vx / speed) * maxSpeed;
                    h.vy = (h.vy / speed) * maxSpeed;
                }

                h.element.style.transform = `translate(${h.x}px, ${h.y}px)`;
            }

            countYesEl.innerText = cYes;
            countNoEl.innerText = cNo;

            if (cYes >= 10) {
                if (successMessageEl.style.display !== 'flex') {
                    successMessageEl.style.display = 'flex';
                }
            } else {
                if (successMessageEl.style.display !== 'none') {
                    successMessageEl.style.display = 'none';
                }
            }

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
        });

        function handleOrientation(event) {
            const rawX = event.gamma || 0; 
            const rawY = event.beta || 0;
            
            if (!isCalibrated) {
                if (rawY >= 18 && rawY <= 55) {
                    initialCalibrationBeta = rawY;
                } else {
                    initialCalibrationBeta = 40;
                }
                calibrationOffsetBeta = initialCalibrationBeta;
                isCalibrated = true;
            }

            const speed = Math.abs(rawY - lastBeta) + Math.abs(rawX - lastGamma);
            
            if (Math.abs(rawY) <= 3 && Math.abs(rawX) <= 3 && speed < 0.5) {
                if (flatStableStartTime === 0) {
                    flatStableStartTime = Date.now();
                } else if (Date.now() - flatStableStartTime > 1000) {
                    calibrationOffsetBeta = 0;
                    isOnTable = true;
                }
            } else {
                flatStableStartTime = 0;
            }

            if (isOnTable && rawY > 15) {
                calibrationOffsetBeta = initialCalibrationBeta;
                isOnTable = false;
            }

            lastBeta = rawY;
            lastGamma = rawX;

            const effectiveY = rawY - calibrationOffsetBeta;

            tiltX = rawX / 45; 
            tiltY = effectiveY / 45; 
        }

        function findHeartAt(x, y) {
            for (let i = hearts.length - 1; i >= 0; i--) {
                let h = hearts[i];
                if (h.isDragged) continue; 
                if (x >= h.x - 20 && x <= h.x + h.size + 20 &&
                    y >= h.y - 20 && y <= h.y + h.size + 20) {
                    return h;
                }
            }
            return null;
        }

        window.addEventListener('touchstart', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const h = findHeartAt(t.clientX, t.clientY);
                if (h) {
                    h.isDragged = true;
                    h.currentBasket = null;
                    h.element.style.opacity = '1'; 
                    h.element.classList.remove('green', 'red');
                    
                    activeDrags.set(t.identifier, {
                        heart: h,
                        offX: t.clientX - h.x,
                        offY: t.clientY - h.y
                    });
                }
            }
        }, {passive: false});

        window.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const dragData = activeDrags.get(t.identifier);
                if (dragData) {
                    dragData.heart.x = t.clientX - dragData.offX;
                    dragData.heart.y = t.clientY - dragData.offY;
                }
            }
        }, {passive: false});

        function endTouch(e) {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const dragData = activeDrags.get(t.identifier);
                if (dragData) {
                    dragData.heart.isDragged = false;
                    
                    const basketType = checkBasketEntry(dragData.heart);
                    if (basketType) {
                        dragData.heart.currentBasket = basketType;
                    } else {
                        const normalizedSize = (dragData.heart.size - 30) / 40;
                        dragData.heart.element.style.opacity = 0.6 + (normalizedSize * 0.4);
                    }
                    activeDrags.delete(t.identifier);
                }
            }
        }
        window.addEventListener('touchend', endTouch);
        window.addEventListener('touchcancel', endTouch);

        window.addEventListener('mousedown', (e) => {
            const h = findHeartAt(e.clientX, e.clientY);
            if (h) {
                h.isDragged = true;
                h.currentBasket = null;
                h.element.style.opacity = '1';
                h.element.classList.remove('green', 'red');
                activeDrags.set('mouse', {
                    heart: h,
                    offX: e.clientX - h.x,
                    offY: e.clientY - h.y
                });
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (activeDrags.size === 0 && (!window.DeviceOrientationEvent || !('ontouchstart' in window))) {
                const centerX = width / 2;
                const centerY = height / 2;
                tiltX = (e.clientX - centerX) / centerX;
                tiltY = (e.clientY - centerY) / centerY;
            }
            const dragData = activeDrags.get('mouse');
            if (dragData) {
                dragData.heart.x = e.clientX - dragData.offX;
                dragData.heart.y = e.clientY - dragData.offY;
            }
        });

        window.addEventListener('mouseup', () => {
            const dragData = activeDrags.get('mouse');
            if (dragData) {
                dragData.heart.isDragged = false;
                const basketType = checkBasketEntry(dragData.heart);
                if (basketType) {
                    dragData.heart.currentBasket = basketType;
                } else {
                    const normalizedSize = (dragData.heart.size - 30) / 40;
                    dragData.heart.element.style.opacity = 0.6 + (normalizedSize * 0.4);
                }
                activeDrags.delete('mouse');
            }
        });

        function startGame() {
            startBtn.style.display = 'none';
            gameLayer.style.display = 'block';
            container.style.display = 'block';
            instructionTxt.style.display = 'block';
            setTimeout(() => instructionTxt.style.opacity = 1, 100);
            initHearts();
            animate();
            startSlideshow(); // Start slideshow
            
            // Nastavenie veƒækosti pre prv√Ω slide
            if (slide1.complete) {
                updateFrameSize(slide1);
            } else {
                slide1.onload = () => updateFrameSize(slide1);
            }
        }

        startBtn.addEventListener('click', () => {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                        }
                        startGame();
                    })
                    .catch(e => {
                        console.error(e);
                        startGame();
                    });
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
                startGame();
            }
        });

        basketGoneEl.addEventListener('click', () => {
            basketGoneEl.style.display = 'none';
        });
    </script>
</body>
</html>
